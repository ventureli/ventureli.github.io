---
layout:     post
title:      "QQ浏览器HD小说阅读界面优化"
subtitle:   " \"渲染优化\""
date:       2017-02-05 12:00:00
author:     "VentureLi"
header-img: "img/home-bg-art.jpg"
catalog: true
tags:
    - iOS
    - 图形图像处理
---

# QQ浏览器HD小说阅读界面优化
>小胖在入职QQ浏览器HD（北京）的一年多后一直负责QQ浏览器的小说界面，前期小说是用web写的，后来采用了Native实现，native实现的话就会有性能需要优化的东西，前前后后总共实验了三个版本才搞定。这里做一个记录。

## 小说整体实现介绍
小说的整个实现使用CoreText排版进行的，具体的使用

## 问题产生
>小说阅读是iPAD的一直主要的内容使用场景，之前第一版我们只上线了，分页阅读，就是一页一页的渲染，然后不同页面之前的切换有层叠，渐变，滑动三种形式，比较简单，因为是分页阅读没有卡顿的问题，内存占比也比较少，因为我们只要有三页的内容在内存里，然后在切换的过程中有动画，完全可以能够对其他面进行预处理和加载。整个页面的样子大约如下

<div  align="center" >    
<img src="/img/postimg/noveloptimize/1.png"/>
</div>

>但是后来产品需要要求连续的滚动滑动，这个就是比较麻烦的一件事了。因为我们要综合考虑内存和卡顿的情况，比如快速滚动的过程中有卡顿，肯定是不行的，但是没有卡顿就要预先处理，那么内存又上去了，这要取一个平衡才行。

<div  align="center" >    
<img src="/img/postimg/noveloptimize/2.png"/>
</div>

**这个问题我前后做了三个版本，最终才找到最优的解决方案**


## 优化方案1
当然，首先想到的还是用分页的方式，那么三个页面滚动的时候，我可以在didscroll的时候进行轮换，那么这样渲染起来比较简单，也不是很占内存。具体的示意图如下。
<div  align="center" >    
<img src="/img/postimg/noveloptimize/3.png"  />
</div>
**这种方案的占用内存很少，但是在快速滚动过程中实在是跳动太明显，放弃了**
另外这种方案还有一个问题，如果有些章节文字太短，需要好多章节在一起才能构成一页的话，计算起来也很麻烦。

## 优化方案2
这个次我吸取了方案1的教训，因为用三页来做缓存的问题是你只要上下滚动一点点都会触发切换页面，那么我把三个页面设计长一点，让每个页面都能独立的超过屏幕高度很多，那么我可以有充足的时间进行预渲染和计算。所以方案二如下：我把三页提升为三章节（每一章节比较长，注意这里不是自然分段的章节意思，一个里面可能有很多章节或者只有一个），这样每一个缓存的模块里至少有一章节。
<div  align="center" >    
<img src="/img/postimg/noveloptimize/4.png"  />
</div>
**这种方案的实现不难，也不卡顿了，但是新的问题出现了，如果一个章节的内存太长的话，会直接导致内存飙升。这个问题就打了，我们很多时候宁愿卡顿也不要内存crash的，所以经过尝试后放弃**

## 优化方案2.5
>在方案3的前面其实还有一个方案2.5 我当时想到了，但是没有进行实现，因为想到了更好的方案3啊。方案2.5就是不是按照最好一章当做一个缓存模块，而是以长度来进行，每个缓存模块为3个屏幕长度，那么整个内处理占用9个屏幕大小的图片内存大小，这样应该也是比较好的解决办法。但是直接方案2.5没有进行代码验证，因为后来直接采用了方案3


## 优化方案3
方案3的想法来自于深入学习了coretext后，深入学习coretext的文章venture会再开一个博文进行仔细阐述，这里只介绍一下。我们现在面临的问题是

* 要用Coretext 排版结果
* 要顺滑就要有预排版
* 要低内存

**表面上看起来这几个要求有点冲突，尤其是第二条和第三条**，但是学习coretext后我们知道coretext的排版粒度是很细的，这里借用本作者其他博客的图片一张。

<div  align="center" >    
<img src="/img/postimg/noveloptimize/6.png"  />
</div>
大致分为这些层级，我之前按照页来排版，大致只使用到了CTFrame和CGpath也就是整块排版。但是我们排版的粗粒度可以更细小，那么很正常我们可以用CTline，也就说整行渲染。所以最终方案3的设计如下：
<div  align="center" >    
<img src="/img/postimg/noveloptimize/7.png"/>
</div>
我们采用CTLine来作为渲染的单位，不断的提取CtLine，然后存储到TableView的dataSource中，随时计算和追加，同事利用复用，异步，一次排版多次绘制等方式提升帧率达到最终效果

## 结果与对比

* 我们和方案一对比下卡顿

 <div  align="center" >    
<img src="/img/postimg/noveloptimize/8.png"  />
</div>


* 我们和方案二对比下内存


 <div  align="center" >    
<img src="/img/postimg/noveloptimize/9.png"  />
</div>

