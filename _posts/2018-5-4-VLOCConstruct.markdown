---
layout:     post
title:      "如何从0开始写一个OC语言的编译器和虚拟机(2)"
subtitle:   "总架构"
date:       2018-5-4 12:00:00
author:     "VentureLi"
header-img: "img/post-bg-ios9-web.jpg"
header-mask:  0.3
catalog:      true
tags:
    - VLOCInterpreter
    - 编译器
    - 虚拟机
    - OC
---
 

# 如何从0开始写一个OC语言的编译器和虚拟机(2) - 总架构

## 编译原理与VLOCInterpreter
要写一个编译器和虚拟机就要设计编译原理，所以在正式开始解析代码前，我们来说下我们整个VLOCInterpreter的整体架构，正VLOC解释器分为两个部分。

 * 编译器 ，把VLOC language 解析为中间代码 
 * 虚拟机 ，运行中间代码，返回结果。

左边是一个正常的语言的编译原理，右侧是一个VLOC解释器的原理。

<div  align="center" >    
<img src="../img/postimg/vloc/construct/1.png"/>
</div>

可以看到VLOC是把编译原理中的，语法解析，词法解析还有中间代码合并成一个编译器前端，输出的是中间代码。
中间代码没有记性代码优化，那么也就是说，下面这种代码也确实要在里面执行1000次的。

```
NSInteger i = 1000;
while(i >=0)
{
  i --;//虽然什么都没做，但是也要执行1000次的。
}
```

虚拟机是运行中间代码的，和其他的虚拟机不同，我们的虚拟机是整个架构在OCRunTime上的，也就是我们没有直接和c语言的虚拟机一样生成代码段，文本段，而是通过OCRunTime作为驱动，通过OCRuntime作为驱动的好处是，可以快速方便的构建我们的虚拟机，而且可以比较完美的兼容oc的特性。比如@selector 这个关键词，我们可以直接映射到OC的selector上。

## 中间代码格式
 VLOCInterpreter 这个解释器的输入肯定就是OC .m 源代码了,但是.m 文件的源代码的冗余信息太多，没办法作为我们虚拟机可以直接运行的命令队列，所以我们这里需要把.m 文件中的源码，翻译成中间命令队列。
 在整个编译原理中，中间代码有很多中格式，比如三地址码，四地址码，逆波兰表达式等。用哈工大的编译原理课件来总结下如下：

<div  align="center" >    
<img src="../img/postimg/vloc/construct/3.png"/>
</div>
 
 这里做个解释：我们针对一个表达式：
 
```
sum=(10+20)*(num+suare);

```

### 逆波兰表达式

上面的表达式逆波兰表达式是：

```
sum 10 20 + num square+*=
```
逆波兰表达式的计算方式是：
从左往右遍历，当遇到 操作数/标识符  压入栈里面，遇到一个操作符的时候，从里面栈里面弹出2个操作数（弹出几个取决于操作符是几目的，比如正负号就是单目的，只取一个操作数）然后把结果压入栈里。

以此表达式为例子：
假设符号表中：num = 100，square = 200 
* 依次压栈sum ，10 ，20 
  
```
栈内：sum ，10 ，20
```
* 遇到 + 双目操作符，把20 和 10 弹出 ，做加法运算，结果为30
* 把30压入栈中

```
栈内：sum ，30，
```
* 把num 压入栈中，把square 压入栈中，

```
栈内：sum ，30，num，square
```
* 遇到+ 双目操作符，把 squre ，num ，弹出，把num+suare ， num+square = 100+200 = 300 ，压入栈中

```
栈内：sum ，30，300
```

* 遇到* 双目操作符，把 300 ，30 ，弹出 ，把 30 *300 ，压入栈中


```
栈内：sum ，9000
```
* 遇到= 双目操作符，把 9000 ，sum ，弹出 把sum赋值9000 

* 退出